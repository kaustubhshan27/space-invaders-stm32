/*
 * space_invaders.c
 *
 *  Created on: Aug 3, 2023
 *      Author: kaustubh
 */

#include <stdint.h>
#include <string.h>
#include "stm32f4xx_hal.h"
#include "space_invaders.h"
#include "nokia5110.h"
#include "gpio.h"
#include "random.h"
#include "FreeRTOS.h"
#include "task.h"
#include "semphr.h"

// image of the player's ship
// includes two blacked out columns on the left and right sides of the image to prevent smearing when moved 2 pixels to the left or right
// width=18 x height=8
static const uint8_t player_ship[] = { 0x42, 0x4D, 0xD6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x12,
		0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0xC4,
		0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
		0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80,
		0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00,
		0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF,
		0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
		0xFF, 0xFF, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x00,
		0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x00,
		0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x0A, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xA0, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0xAA, 0xA0, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0xAA, 0xA0, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xFF };

// a laser burst in flight
// includes one blacked out row on the top and bottom of the image to prevent smearing when moved 1 pixel up or down
// width=2 x height=9
static const uint8_t laser[] = { 0x42, 0x4D, 0x9A, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x02, 0x00,
		0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80,
		0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80,
		0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00,
		0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00,
		0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF,
		0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0xBB, 0x00,
		0x00, 0x00, 0xAA, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00,
		0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xFF };

// small shield floating in space to cover the player's ship from enemy fire (undamaged)
// width=18 x height=5
static const uint8_t bunker_light[] = { 0x42, 0x4D, 0xB2, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00,
		0x12, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00,
		0xC4, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00,
		0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00,
		0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00,
		0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00,
		0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA,
		0xAA, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xA0, 0x00, 0x00, 0x00, 0x0A, 0xAA,
		0xAA, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
		0xAA, 0x00, 0x00, 0x00, 0x0A, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
		0xA0, 0x00, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
		0x00, 0x00, 0x00, 0x00, 0xFF };

// small shield floating in space to cover the player's ship from enemy fire (moderate generic damage)
// width=18 x height=5
static const uint8_t bunker_medium[] = { 0x42, 0x4D, 0xB2, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00,
		0x12, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00,
		0xC4, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00,
		0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00,
		0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00,
		0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00,
		0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xAA, 0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA,
		0xAA, 0x00, 0x00, 0x00, 0xAA, 0xAA, 0xA0, 0x00, 0x00, 0x00, 0x0A, 0xAA,
		0x0A, 0x00, 0x00, 0x00, 0x0A, 0x0A, 0xAA, 0xAA, 0xAA, 0xAA, 0xA0, 0xAA,
		0xAA, 0x00, 0x00, 0x00, 0x0A, 0xAA, 0x0A, 0xA0, 0xA0, 0xAA, 0xAA, 0xA0,
		0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0xA0, 0x00, 0x0A, 0x0A, 0x0A,
		0x00, 0x00, 0x00, 0x00, 0xFF };

// small shield floating in space to cover the player's ship from enemy fire (heavy generic damage)
// width=18 x height=5
static const uint8_t bunker_heavy[] = { 0x42, 0x4D, 0xB2, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00,
		0x12, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00,
		0xC4, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00,
		0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00,
		0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00,
		0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00,
		0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0x0A, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0,
		0xAA, 0x00, 0x00, 0x00, 0xAA, 0x0A, 0xA0, 0x00, 0x00, 0x00, 0x0A, 0xAA,
		0x0A, 0x00, 0x00, 0x00, 0x0A, 0x0A, 0x0A, 0xA0, 0xAA, 0xA0, 0xA0, 0xA0,
		0xA0, 0x00, 0x00, 0x00, 0x00, 0xAA, 0x0A, 0x00, 0xA0, 0xA0, 0xA0, 0x00,
		0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x0A, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0xFF };

// enemy ship that starts at the top of the screen (arms/mouth closed)
// width=16 x height=10
static const uint8_t enemy_ship[] = { 0x42, 0x4D, 0xC6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10,
		0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
		0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80,
		0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00,
		0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF,
		0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
		0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x0F, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00,
		0x0F, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0xF0, 0xF0, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x0F, 0xF0,
		0xFF, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF };

// small explosion best used for the demise of an enemy
// width=16 x height=10
const uint8_t small_explosion[] = { 0x42, 0x4D, 0xC6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10,
		0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
		0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80,
		0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00,
		0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF,
		0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
		0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xF0, 0x0F, 0x00, 0x0F, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0x00, 0xF0, 0xF0,
		0x0F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x0F,
		0xF0, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00,
		0xF0, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
		0xF0, 0x00, 0xF0, 0xF0, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x0F,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF };

// large explosion that can be used upon the demise of the player's ship (first frame)
// width=18 x height=8
const uint8_t big_explosion[] = { 0x42, 0x4D, 0xD6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x12,
		0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
		0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80,
		0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00,
		0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF,
		0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
		0xFF, 0xFF, 0x00, 0x0A, 0x00, 0x09, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x90, 0xB0, 0x0A, 0x00, 0x0B, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x0B, 0xA0, 0x00, 0xE0, 0x00, 0x00, 0x90, 0x90, 0x9A,
		0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0xA0, 0x00, 0x00, 0xAE, 0x00,
		0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0xE0, 0x0A, 0x0A, 0x00, 0x00, 0xB0,
		0x00, 0x00, 0x00, 0xA0, 0x00, 0x09, 0x00, 0x00, 0x00, 0x90, 0x00, 0x0A,
		0x00, 0x00, 0x00, 0xFF };

// collection of all the objects involved in the game
game_objects_t game_entities;

// collection of all the current stats of the game
game_stats_t game_info;

// semaphore to indicate user missile creation
static SemaphoreHandle_t xSemaphrHandle_user_missile_gen = NULL;

// global tick count variable
extern volatile uint32_t uwTick;

static void lasers_init(void) {
	// initializing all user lasers
	for (uint8_t i = 0; i < USER_MISSILE_MAX; i++) {
		/* if the user laser is going to hit an enemy sprite -
		 * enemy0: hit_status = 0,
		 * enemy1: hit_status = 1,
		 * enemy2: hit_status = 2,
		 * else hit_status = -1 */
		game_entities.user_laser[i].hit_status = -1;
		game_entities.user_laser[i].laser_sprite.x = 0;
		game_entities.user_laser[i].laser_sprite.y = 0;
		game_entities.user_laser[i].laser_sprite.image = laser;
		game_entities.user_laser[i].laser_sprite.life = 0;
	}

	// initializing all enemy lasers
	for (uint8_t i = 0; i < ENEMY_MISSILE_MAX; i++) {
		/* if the enemy laser is going to hit the bunker -
		 * hit_status = 1,
		 * else hit_status=0 */
		game_entities.enemy_laser[i].hit_status = 0;
		game_entities.enemy_laser[i].laser_sprite.x = 0;
		game_entities.enemy_laser[i].laser_sprite.y = 0;
		game_entities.enemy_laser[i].laser_sprite.image = laser;
		game_entities.enemy_laser[i].laser_sprite.life = 0;
	}
}

static void sprites_pos_init(void) {
	// enemy initialization
	for (uint8_t i = 0; i < NUMBER_OF_ENEMIES; i++) {
		game_entities.enemy[i].x = 32 * i;
		game_entities.enemy[i].y = ENEMYH - 1;
		game_entities.enemy[i].image = enemy_ship;
		game_entities.enemy[i].life = 1;
	}

	// player initialization
	game_entities.user.x = 32;
	game_entities.user.y = 47;
	game_entities.user.image = player_ship;
	game_entities.user.life = 1;

	// bunker initialization
	game_entities.bunker.x = 32;
	game_entities.bunker.y = 47 - PLAYERH;
	game_entities.bunker.image = bunker_light;
	game_entities.bunker.life = 3;
}

static void draw(void) {
	// clearing the buffer before drawing
	Nokia5110_ClearBuffer();

	// filling the buffer with enemies
	for (uint8_t i = 0; i < NUMBER_OF_ENEMIES; i++) {
		if (game_entities.enemy[i].life > 0) {
			Nokia5110_PrintBMP(game_entities.enemy[i].x,
					game_entities.enemy[i].y, game_entities.enemy[i].image, 0);
		}
	}

	// filling the buffer with the user
	if (game_entities.user.life > 0) {
		Nokia5110_PrintBMP(game_entities.user.x, game_entities.user.y,
				game_entities.user.image, 0);
	}

	// filling the buffer with the bunker
	if (game_entities.bunker.life > 0) {
		Nokia5110_PrintBMP(game_entities.bunker.x, game_entities.bunker.y,
				game_entities.bunker.image, 0);
	}

	// filling the buffer with the user lasers
	for (uint8_t i = 0; i < USER_MISSILE_MAX; i++) {
		if (game_entities.user_laser[i].laser_sprite.life > 0) {
			Nokia5110_PrintBMP(game_entities.user_laser[i].laser_sprite.x,
					game_entities.user_laser[i].laser_sprite.y,
					game_entities.user_laser[i].laser_sprite.image, 0);
		}
	}

	// filling the buffer with the enemy lasers
	for (uint8_t i = 0; i < ENEMY_MISSILE_MAX; i++) {
		if (game_entities.enemy_laser[i].laser_sprite.life > 0) {
			Nokia5110_PrintBMP(game_entities.enemy_laser[i].laser_sprite.x,
					game_entities.enemy_laser[i].laser_sprite.y,
					game_entities.enemy_laser[i].laser_sprite.image, 0);
		}
	}

	// display the buffer on Nokia 5110
	Nokia5110_DisplayBuffer();
}

static void game_start_msg(void) {
	Nokia5110_Clear();
	Nokia5110_SetCursor(1, 1);
	Nokia5110_OutString("SPACE");
	Nokia5110_SetCursor(1, 2);
	Nokia5110_OutString("INVADERS");
	Nokia5110_SetCursor(1, 4);
	Nokia5110_OutString("Begin Game!");
}

void game_end_msg(void) {
	Nokia5110_Clear();

	if (game_entities.user.life == 0) {
		/* player lost message */
		Nokia5110_SetCursor(1, 1);
		Nokia5110_OutString("GAME OVER");
		Nokia5110_SetCursor(1, 2);
		Nokia5110_OutString("Try Again,");
		Nokia5110_SetCursor(1, 3);
		Nokia5110_OutString("Earthling!");
		Nokia5110_SetCursor(2, 4);
		Nokia5110_OutUDec(game_info.kill_count * POINTS_PER_KILL);
	} else if (game_entities.user.life == 1) {
		/* player won message */
		Nokia5110_SetCursor(1, 1);
		Nokia5110_OutString("YOU WON!");
		Nokia5110_SetCursor(2, 4);
		Nokia5110_OutUDec(game_info.kill_count * POINTS_PER_KILL);
	}
}

void game_init(void) {
	/* initialize the game entities */
	sprites_pos_init();
	lasers_init();
	memset((void*) &game_info, 0, sizeof(game_stats_t));

	/* seed the RNG */
	Random_Init(uwTick);

	/* display the game start message */
	game_start_msg();

	/* let the start message persist on the display - 3 secs */
	HAL_Delay(PERSIST_PERIOD);

	/* display the initial playing position */
	draw();
}

void user_laser_generation(void) {
	while (1) {
		if (xSemaphoreTake(xSemaphrHandle_user_missile_gen, portMAX_DELAY)
				== pdPASS) {

			/* generate the laser */
			uint8_t missile_index;
			for (missile_index = 0; missile_index < USER_MISSILE_MAX;
					missile_index++) {
				if (game_entities.user_laser[missile_index].laser_sprite.life
						== 0) {
					game_entities.user_laser[missile_index].laser_sprite.x =
							game_entities.user.x + (PLAYERW / 2) - 1;
					game_entities.user_laser[missile_index].laser_sprite.y = 47
							- PLAYERH;
					game_entities.user_laser[missile_index].laser_sprite.image =
							laser;
					game_entities.user_laser[missile_index].laser_sprite.life =
							1;

					break;
				}
			}

			game_entities.user_laser[missile_index].hit_status = -1;

			/* check which enemy the generated laser is destined to hit */
			for (uint8_t i = 0; i < NUMBER_OF_ENEMIES; i++) {
				if ((game_entities.user_laser[missile_index].laser_sprite.x
						>= game_entities.enemy[i].x)
						&& (game_entities.user_laser[missile_index].laser_sprite.x
								<= game_entities.enemy[i].x + ENEMYW)) {
					game_entities.user_laser[missile_index].hit_status = i;
					break;
				}
			}
		}
	}
}

void enemy_laser_generation(void) {
	TickType_t xLastWakeTime = xTaskGetTickCount();

	while (1) {
		/* generate an enemy laser with a period of 2 secs */
		vTaskDelayUntil(&xLastWakeTime,
		ENEMY_LASER_GENERATION_PERIOD / portTICK_PERIOD_MS);

		if (game_info.enemy_missile_count < ENEMY_MISSILE_MAX) {
			uint8_t enemy_choice = (Random32() >> 24) % NUMBER_OF_ENEMIES;
			/* using bits 31-24 of the random number will produce a number sequence with a cycle length of 2^24 */
			while (game_entities.enemy[enemy_choice].life == 0) {
				enemy_choice = (Random32() >> 24) % NUMBER_OF_ENEMIES;
			}

			game_info.enemy_missile_count++;

			for (uint8_t i = 0; i < ENEMY_MISSILE_MAX; i++) {
				if (game_entities.enemy_laser[i].laser_sprite.life == 0) {
					game_entities.enemy_laser[i].laser_sprite.x =
							game_entities.enemy[enemy_choice].x + ENEMYW / 2
									- 1;
					game_entities.enemy_laser[i].laser_sprite.y =
							game_entities.enemy[enemy_choice].y + ENEMYH;
					game_entities.enemy_laser[i].laser_sprite.image = laser;
					game_entities.enemy_laser[i].laser_sprite.life = 1;

					if (((game_entities.enemy_laser[i].laser_sprite.x
							>= game_entities.bunker.x)
							&& (game_entities.enemy_laser[i].laser_sprite.x
									<= game_entities.bunker.x + BUNKERW))
							&& game_entities.bunker.life != 0) {
						game_entities.enemy_laser[i].hit_status = 1;
					} else {
						game_entities.enemy_laser[i].hit_status = 0;
					}
					break;
				}
			}

		}
	}
}

void laser_movement(void) {
	TickType_t xLastWakeTime = xTaskGetTickCount();

	while (1) {
		/* generate an enemy laser with a period of 0.5 secs */
		vTaskDelayUntil(&xLastWakeTime,
		LASER_MOVEMENT_PERIOD / portTICK_PERIOD_MS);

		/* user laser movement */
		if (game_info.user_missile_count > 0) {
			for (uint8_t i = 0; i < USER_MISSILE_MAX; i++) {
				if (game_entities.user_laser[i].laser_sprite.life == 1) {
					game_entities.user_laser[i].laser_sprite.y -=
					USER_LASER_DISPLACEMENT;

					if ((game_entities.user_laser[i].hit_status >= 0)
							&& ((game_entities.user_laser[i].laser_sprite.y
									- LASERH)
									<= game_entities.enemy[game_entities.user_laser[i].hit_status].y)) {
						game_entities.enemy[game_entities.user_laser[i].hit_status].image =
								small_explosion;
						game_entities.user_laser[i].hit_status = -1;
						game_entities.user_laser[i].laser_sprite.life = 0;
						game_info.user_missile_count--;
						game_info.kill_count++;
						if (game_info.kill_count == NUMBER_OF_ENEMIES) {
							game_info.game_over_flag = 1;
						}
					} else if (game_entities.enemy[game_entities.user_laser[i].hit_status].y
							<= 0) {
						game_entities.user_laser[i].hit_status = -1;
						game_entities.user_laser[i].laser_sprite.life = 0;
						game_info.user_missile_count--;
					}
				}
			}
		}

		/* enemy laser movement */
		if (game_info.enemy_missile_count > 0) {
			for (uint8_t i = 0; i < ENEMY_MISSILE_MAX; i++) {
				if (game_entities.enemy_laser[i].laser_sprite.life == 1) {
					game_entities.enemy_laser[i].laser_sprite.y +=
					ENEMY_LASER_DISPLACEMENT;

					if (game_entities.enemy_laser[i].hit_status == 1) /* enemy laser to hit the bunker */
					{
						if ((game_entities.enemy_laser[i].laser_sprite.y
								>= game_entities.bunker.y - BUNKERH)
								&& (game_entities.bunker.life > 0)) {
							if (game_entities.bunker.life > 0) {
								game_entities.bunker.life--;
							}
							switch (game_entities.bunker.life) {
							case 1:
								game_entities.bunker.image = bunker_heavy;
								break;
							case 2:
								game_entities.bunker.image = bunker_medium;
								break;
							default:
								break;
							}
						}
					} else if ((game_entities.enemy_laser[i].laser_sprite.x
							>= game_entities.user.x)
							&& (game_entities.enemy_laser[i].laser_sprite.x
									<= game_entities.user.x + PLAYERW)) /* enemy laser to hit the user */
							{
						if (game_entities.enemy_laser[i].laser_sprite.y
								>= game_entities.user.y - PLAYERH) {
							game_entities.user.image = big_explosion;
							game_entities.enemy_laser[i].laser_sprite.life = 0;
							game_info.game_over_flag = 1;
							game_info.enemy_missile_count--;
						}
					} else if (game_entities.enemy_laser[i].laser_sprite.y
							- LASERH >= SCREENH - 1) {
						game_entities.enemy_laser[i].laser_sprite.life = 0;
						game_info.enemy_missile_count--;
					}
				}
			}
		}
	}
}

void draw_image(void) {
	TickType_t xLastWakeTime = xTaskGetTickCount();

	/* generate an enemy laser with a period of 0.5 secs */
	vTaskDelayUntil(&xLastWakeTime,
	SCREEN_REFRESH_PERIOD / portTICK_PERIOD_MS);

	while (1) {
		draw();
	}
}

void space_invaders_app(void) {
	TaskHandle_t xTaskHandle_userLaserGeneration = NULL;
	TaskHandle_t xTaskHandle_enemyLaserGeneration = NULL;
	TaskHandle_t xTaskHandle_laserMovement = NULL;
	TaskHandle_t xTaskHandle_drawImage = NULL;

	/* initialize all game metrics */
	game_init();

	/* to synchronize with the user missile generation task */
	assert_param(
			vSemaphoreCreateBinary(xSemaphrHandle_user_missile_gen) != NULL);

	/* task to draw an image to Nokia 5110 */
	assert_param(
			xTaskCreate((pdTASK_CODE) draw_image, "Draw Image", TASK_STACK_SIZE, NULL,
					1, &xTaskHandle_drawImage) == pdPASS);

	/* create the user laser generation task */
	assert_param(
			xTaskCreate((pdTASK_CODE) user_laser_generation,
					"User Laser Generation", TASK_STACK_SIZE, NULL, 1,
					&xTaskHandle_userLaserGeneration) == pdPASS);

	/* create the enemy laser generation task */
	assert_param(
			xTaskCreate((pdTASK_CODE) enemy_laser_generation,
					"Enemy Laser Generation", TASK_STACK_SIZE, NULL, 1,
					&xTaskHandle_enemyLaserGeneration) == pdPASS);

	/* create the user and enemy laser movement task */
	assert_param(
			xTaskCreate((pdTASK_CODE) laser_movement,
					"User & Enemy Laser Movement", TASK_STACK_SIZE, NULL, 1,
					&xTaskHandle_laserMovement) == pdPASS);

	while (1) {
		if (get_user_button_status()) {
			if (game_info.user_missile_count < USER_MISSILE_MAX) {
				game_info.user_missile_count++;
				xSemaphoreGive(xSemaphrHandle_user_missile_gen);
			}
		}

		/* if the game has ended, display the final image */
		if (game_info.game_over_flag) {
			/* let the  last image of the game persist on the display - 3 secs */
			vTaskDelay(PERSIST_PERIOD / portTICK_PERIOD_MS);
			game_end_msg();

			/* delete all tasks */
			vTaskDelete(xTaskHandle_laserMovement);
			vTaskDelete(xTaskHandle_enemyLaserGeneration);
			vTaskDelete(xTaskHandle_userLaserGeneration);
			vTaskDelete(xTaskHandle_drawImage);
			vTaskDelete(NULL);
		}
	}
}
